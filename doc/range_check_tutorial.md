# __circom__ and __snarkjs__ using range check custom gate

This is a tutorial on how to use the range check custom gates inside __snarkjs__ with _PLONK_. The aim of the tutorial is to guide you in all the workflow from designing the circuit to verifying it on-chain.
You can find the math [range protocol rolled out in this paper](./range_check_plookup_protocol.md). 

## Tools

Following are the tools you need to have installed in order to follow this tutorial:

### node.js

You need Node.js Javascript runtime installed. LTS version and current version with latest features are supported. Please, refer to [Node.js website](https://nodejs.org) to install the runtime.

### circom

__circom__ is a hardware description language for designing arithmetic circuits that can be used to generate zero-knowledge proofs. Since 2.0.6 version __circom__ language allows the definition of custom templates. If you are using previous version you need to update to the latest one or at least at 2.0.6 version.

To install or update __circom__ you can refer at [circom documentation](https://docs.circom.io/getting-started/installation/) or [circom github repository](https://github.com/iden3/circom).

### snarkjs

__snarkjs__ is a JavaScript and Pure Web Assembly implementation of _zkSNARK_ and _PLONK_ schemes. We'll use __snarkjs__ to import r1cs file data generated from __circom__, generate the proof, prove the proof or to generate a solidity verifier.

To install or update __snarkjs__ please refere to [snarkjs github repository](https://github.com/iden3/snarkjs).

## Write our circuit
Let's create a circuit that tries to prove a number is between a lower bound and an upper bound.

1. Create and empty directory named `rccircuit`.
1. Create a new file named `range_check.circom` with the following content:
```text
pragma circom 2.0.6;
pragma custom_templates;

template custom RangeCheck() {
    signal input lower_bound;
    signal input upper_bound;
    signal input to_check;

    assert(lower_bound <= to_check && to_check <= upper_bound);
}
```
This file defines a range check custom template circuit. The template has three inputs: lower_bound, upper_bound and the to_check value. The circuit checks if `lower_bound <= to_check <= upper_bound`.

For more info on custom templates syntax refer to [circom custom templates documentation](https://docs.circom.io/circom-language/templates-and-components/#custom-templates).


3. Create a new file named `circuit.circom`with the following content:
```text
pragma circom 2.0.6;
pragma custom_templates;

include "range_check.circom";

template Circuit() {
    signal input lower_bound;
    signal input upper_bound;
    signal input to_check;

    component rangeCheck = RangeCheck();

    rangeCheck.lower_bound <== lower_bound;
    rangeCheck.upper_bound <== upper_bound;
    rangeCheck.to_check    <== to_check;
}

component main {public [lower_bound, upper_bound, to_check]} = Circuit();
```
This file creates the `main` circuit based on the template `Circuit`. This template has three inputs: `lower_bound`, `upper_bound` and `to_check` inputs. Inside the `Circuit` template it creates a new instance of the `RangeCheck` temaplate and assigns their inputs.

4. We are now ready to compile the circuit with the following command:
```console
> circom circuit.circom --O0 --r1cs --wasm --sym

template instances: 2
non-linear constraints: 0
linear constraints: 3
public inputs: 3
public outputs: 0
private inputs: 0
private outputs: 0
wires: 7
labels: 7
Written successfully: ./circuit.r1cs
Written successfully: ./circuit.sym
Written successfully: ./circuit_js/circuit.wasm
Everything went okay, circom safe
```
This command generates the files `circuit.r1cs`, `circuit.sym` and the folder `circuit_js` where you can find all the autogenerated code to compute a witness file. The autogenerated code can be in c++ and/or javascript/wasm. ÂºFor the current example we'll use the javascript/wasm version. 

## Compute a witness

Now we need to compute all the intermediate signals of the circuit that fullfills the constraints and the output of the circuit. In order to do that we execute the circuit with all the inputs required by the circuit defined in `circuit.circom`. The set of intermediate signals and the outputs is the witness.

First, let's create a new file for the inputs named `input.json` with the following content:
```text
{
  "lower_bound": 71,
  "upper_bound": 435,
  "to_check": 400
}
```

Now, let's calculate the witness with __snarkjs__:

```console
> snarkjs wtns calculate circuit_js/circuit.wasm input.json witness.wtns
```

This command creates a new witness binary file named `witness.wtns`.

## snarkjs setup
As you know our proving system will be a _PLONK_ scheme that does not require a trusted setup ceremony, it is enough with the universal powers of tau ceremony.

Ptau files for bn128 are [available here](https://github.com/iden3/snarkjs#7-prepare-phase-2).

For this example it's enough with the [powersOfTau28_hez_final_11.ptau](https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_11.ptau) file.

Download the ptau file to the `rccircuit` folder using the browser or execute following command from the `rccircuit` folder:
```console
> curl https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_11.ptau --output powersOfTau28_hez_final_11.ptau
```

Let's execute __snarkjs__ setup process to generate a binary zkey file named `circuit.zkey` which is used from the prover to generate the proof or to generate a verification key for the verifier as we'll see later.

```console
> snarkjs plonk setup circuit.r1cs powersOfTau28_hez_final_11.ptau circuit.zkey

[INFO]  snarkJS: Reading r1cs
[INFO]  snarkJS: Plonk constraints: 11
[INFO]  snarkJS: Plonk setup Finished
```

### _PLONK_ arithmetization on the setup snarkjs process using range check custom gates

As you may know a _PLONK_ equation is defined as follows:
$$q_L(i)x_{a_i} + q_R(i)x_{b_i} + q_O(i)x_{c_i} +  q_M(i)x_{a_i}x_{b_i} + q_C(i) = 0$$

Where "$q$" are the selectors that are publicly known, $x_{a_i}$, $x_{b_i}$ are the left and right input values and $x_{c_i}$ are the output values.

We can modify the _PLONK_ equation to define our own custom operation, a.k.a custom gate, like this:

$$q_L(i)x_{a_i} + q_R(i)x_{b_i} + q_O(i)x_{c_i} +  q_M(i)x_{a_i}x_{b_i} + q_C(i) + q_K(i)x_{k_i} = 0$$

Where $q_K(i)$ is a new selector for the custom gate and $x_{k_i}$ is the value computed by the custom gate.

If we want to check $a <= b$ we can modify the _PLONK_ equation to define our own custom operation, a.k.a custom gate. Our customized _PLONK_ equation could be expressed by the following:

$$q_L(i)x_{a_i} + q_R(i)x_{b_i} + q_O(i)x_{c_i} +  q_M(i)x_{a_i}x_{b_i} + q_C(i) + q_K(i)(x_{a_i}-x_{b_i}) = 0$$

Where for each use of the gate following values are assigned:

<small>
    <table>
        <tr>
            <th colspan="8"><i>PLONK</i> specific</th>
            <th colspan="2">Less or equal</th> 
        </tr>
        <tr>
            <td>x<sub>a<sub>i</sub></sub></td>
            <td>x<sub>b<sub>i</sub></sub></td>
            <td>x<sub>c<sub>i</sub></sub></td>
            <td>q<sub>L</sub></td>
            <td>q<sub>R</sub></td>
            <td>q<sub>O</sub></td>
            <td>q<sub>M</sub></td>
            <td>q<sub>C</sub></td>
            <td>q<sub>K</sub></td>
            <td>x<sub>k<sub>i</sub></sub></td>
        </tr>
        <tr>
            <td>b</td>
            <td>a</td> 
            <td>0</td>
            <td>1</td>
            <td>-1</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
            <td>b - a</td>
        </tr>
</table>
</small>

In the case of a range check we want to check $lower <= value <= upper$. For each range check gate used we create two _PLONK_ equations, one to check $lower <= value$ and the other to check $value <= upper$. The following values are assigned:

<small>
    <table>
        <tr>
            <th colspan="8"><i>PLONK</i> specific</th>
            <th colspan="2">Range check</th> 
        </tr>
        <tr>
            <td>x<sub>a<sub>i</sub></sub></td>
            <td>x<sub>b<sub>i</sub></sub></td>
            <td>x<sub>c<sub>i</sub></sub></td>
            <td>q<sub>L</sub></td>
            <td>q<sub>R</sub></td>
            <td>q<sub>O</sub></td>
            <td>q<sub>M</sub></td>
            <td>q<sub>C</sub></td>
            <td>q<sub>K</sub></td>
            <td>x<sub>k<sub>i</sub></sub></td>
        </tr>
        <tr>
            <td>value</td>
            <td>lower</td> 
            <td>0</td>
            <td>1</td>
            <td>-1</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
            <td>value - lower</td>
        </tr>
        <tr>
            <td>upper</td>
            <td>value</td> 
            <td>0</td>
            <td>1</td>
            <td>-1</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
            <td>upper - value</td>
        </tr>
</table>
</small>

### Polynomials defining the circuit

In the following list, we define the polynomials that this circuit is using:

* The selector polynomials $q_L(X)$, $q_R(X)$, $q_O(X)$, $q_M(X)$, $q_C(X)$ which define the arithmetization of a circuit.
* An additional selector polynomial $q_K(X)$ which activates/deactivates the range check custom gate. More specifically:

$$q_K(\omega^i) = q_{K_i} =
\begin{cases}
1, \text{if the i-th gate must be activated,}\\
0, \text{otherwise}
\end{cases}$$

* $S_{\sigma1}$, $S_{\sigma2}$, $S_{\sigma3}$
* ...

## Create the proof
Let's create the proof using the following command:

```console
> snarkjs plonk prove circuit.zkey witness.wtns proof.json public.json

[INFO]  snarkJS: Plonk prover finished
```

This command generates the file `proof.json` which contains the actual proof and the file `public.json` which contains the public input and output values.

[Prover algorithm documentation can be found here](./range_check_plookup_protocol.md#Prover-Algorithm).

## Verify the proof

In order to verify the proof first we need to export the zkey file created on the previous steps to a verification key.

```console
> snarkjs zkev circuit.zkey verification_key.json

[INFO]  snarkJS: Plonk export verification key finished
```

We just created a new file `verification_key.json` with some of the data used for the verifier to verify the proof. The content of the file should be similar to the following:

```text=
{
 "protocol": "plonk",
 "curve": "bn128",
 "nPublic": 3,
 "power": 4,
 "k1": "2",
 "k2": "3",
 "Qm": [
 
 ...
 ...
 ...
 
 "Qk": [
    "20684007482846524726136619905835682909236888269756303554643445790439119671689",
    "15272585604735344260606687609189820320446189017075864593268802712837712836556",
    "1"
   ]
  }
 ]
}
```

Let's verify the proof using the following command:

```console
> snarkjs plonk verify verification_key.json public.json proof.json

[INFO]  snarkJS: Range check: OK!
[INFO]  snarkJS: Custom gates result: Ok!
[INFO]  snarkJS: OK!
[INFO]  snarkJS: Plonk verifier finished
```

[Verifier algorithm documentation can be found here](./range_check_plookup_protocol.md#Verifier-Algorithm).

## Verifier as a Solidity smart contract
__snarkjs__ is able to create a Solidity smart contract to verify the proof on-chain using [remix](https://remix.ethereum.org/) or similar.

Let's generate the Solidity smart contract with the following command:

```console
> snarkjs zkesv circuit.zkey verifier.sol
```

This command will create a new solidity smart contract file named `verifier.sol` so we can deploy it with remix or similar.
To execute the smart contract we need the call data. We generate it with the following command:

```console
> snarkjs zkesc public.json proof.json

0x26bdcaa99a27fbf8b6ade66bcbf953d2dc8eef2cf227d55b89
...
```

Copy all the output call data and paste it remix on the verifyProof field of the deployed smart contract and it should return a true value meaning that the proof is correct.

That's all !