/*
    Copyright 2018 0KIMS association.

    This file is part of snarkJS.

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

import { utils } from "ffjavascript";

const { unstringifyBigInts, leInt2Buff } = utils;

/**
 * Convert a G1 point to Rust byte array format.
 * Each coordinate: BigInt -> 32 bytes little-endian -> reverse bytes
 * Result: 64 bytes total
 */
function convertG1Point(point) {
    const x = Array.from(leInt2Buff(point[0], 32)).reverse();
    const y = Array.from(leInt2Buff(point[1], 32)).reverse();
    return [...x, ...y];
}

/**
 * Convert a G2 point to Rust byte array format.
 * Each coordinate pair: concatenate both elements (64 bytes), reverse all.
 * Result: 128 bytes total
 */
function convertG2Point(point) {
    const x0 = Array.from(leInt2Buff(point[0][0], 32));
    const x1 = Array.from(leInt2Buff(point[0][1], 32));
    const xCombined = [...x0, ...x1].reverse();

    const y0 = Array.from(leInt2Buff(point[1][0], 32));
    const y1 = Array.from(leInt2Buff(point[1][1], 32));
    const yCombined = [...y0, ...y1].reverse();

    return [...xCombined, ...yCombined];
}

/**
 * Convert a public input scalar to bytes.
 * BigInt -> 32 bytes little-endian -> reverse bytes
 */
function convertScalar(scalar) {
    return Array.from(leInt2Buff(scalar, 32)).reverse();
}

/**
 * Format a byte array as Rust code with line wrapping.
 */
function formatByteArray(arr, indent, bytesPerLine = 16) {
    let lines = [];
    for (let i = 0; i < arr.length; i += bytesPerLine) {
        const slice = arr.slice(i, Math.min(i + bytesPerLine, arr.length));
        lines.push(indent + slice.join(", "));
    }
    return lines.join(",\n");
}

export default async function groth16ExportRustCallData(_proof, _pub) {
    const proof = unstringifyBigInts(_proof);
    const pub = unstringifyBigInts(_pub);

    // Convert proof elements
    const proofA = convertG1Point(proof.pi_a);
    const proofB = convertG2Point(proof.pi_b);
    const proofC = convertG1Point(proof.pi_c);

    // Convert public inputs
    const publicInputs = pub.map(signal => convertScalar(signal));

    // Generate Rust code
    let code = `// Groth16 Proof (generated by snarkJS)
// Note: proof_a may need to be negated before verification depending on the verifier implementation.

/// Proof element A in G1 (64 bytes)
pub const PROOF_A: [u8; 64] = [
${formatByteArray(proofA, "    ")},
];

/// Proof element B in G2 (128 bytes)
pub const PROOF_B: [u8; 128] = [
${formatByteArray(proofB, "    ")},
];

/// Proof element C in G1 (64 bytes)
pub const PROOF_C: [u8; 64] = [
${formatByteArray(proofC, "    ")},
];

/// Public inputs (${publicInputs.length} x 32 bytes)
pub const PUBLIC_INPUTS: [[u8; 32]; ${publicInputs.length}] = [
`;

    for (let i = 0; i < publicInputs.length; i++) {
        code += `    [\n${formatByteArray(publicInputs[i], "        ")},\n    ],\n`;
    }
    code += "];\n";

    return code;
}
