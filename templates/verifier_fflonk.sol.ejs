// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract FflonkVerifier {
    uint32 constant n     = <%= 2**vk.power %>; // Domain size

    // ShPlonk verifier interface
    address public shPlonkVerifierAddress;

    // Verification Key data
    uint256 constant k1   = <%= vk.k1 %>;   // Plonk k1 multiplicative factor to force distinct cosets of H
    uint256 constant k2   = <%= vk.k2 %>;   // Plonk k2 multiplicative factor to force distinct cosets of H

    // OMEGAS
    uint256 constant w1   = <%= vk.w  %>;

    // Verifier preprocessed input 
<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%      if(vk.f[i].stages.length === 1 && vk.f[i].stages[0].stage === 0) {  -%>
    uint256 constant f<%- vk.f[i].index %>x = <%= vk[`f${vk.f[i].index}`][0] %>;
    uint256 constant f<%- vk.f[i].index %>y = <%= vk[`f${vk.f[i].index}`][1] %>;
<%      } -%>
<%  } -%>


    // Scalar field size
    uint256 constant q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    // Proof calldata
    // Byte offset of every parameter of the calldata
    // Polynomial commitments W and Wp
    uint16 constant pW = 4 + 0;
    uint16 constant pWp = 4 + 64;

    // Polynomial commitments fi
<%  let commits = 2 -%>
<%  let count = 128; -%>
<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%      if(vk.f[i].stages.length !== 1 || vk.f[i].stages[0].stage !== 0) { -%>
    uint16 constant pf<%- vk.f[i].index %> = 4 + <%- count %>;
<%      count += 64 -%>
<%      commits += 1 -%>
<%      } -%>
<%  } -%>

    // Opening evaluations
    uint16 constant pEval_QL  = 4 + 32*<%- commits * 2 %>;  // q_L(xi)
    uint16 constant pEval_QR  = 4 + 32*<%- commits * 2 + 1 %>;  // q_R(xi)
    uint16 constant pEval_QO  = 4 + 32*<%- commits * 2 + 2 %>; // q_M(xi)
    uint16 constant pEval_QM  = 4 + 32*<%- commits * 2 + 3 %>; // q_O(xi)
    uint16 constant pEval_QC  = 4 + 32*<%- commits * 2 + 4 %>; // q_C(xi)
    uint16 constant pEval_Sigma1  = 4 + 32*<%- commits * 2 + 5 %>; // S_{sigma_1}(xi)
    uint16 constant pEval_Sigma2  = 4 + 32*<%- commits * 2 + 6 %>; // S_{sigma_2}(xi)
    uint16 constant pEval_Sigma3  = 4 + 32*<%- commits * 2 + 7 %>; // S_{sigma_3}(xi)
    uint16 constant pEval_A   = 4 + 32*<%- commits * 2 + 8 %>; // a(xi)
    uint16 constant pEval_B   = 4 + 32*<%- commits * 2 + 9 %>; // b(xi)
    uint16 constant pEval_C   = 4 + 32*<%- commits * 2 + 10 %>; // c(xi)
    uint16 constant pEval_T2W   = 4 + 32*<%- commits * 2 + 11 %>; // T_2(xi omega)
    uint16 constant pEval_Z  = 4 + 32*<%- commits * 2 + 12 %>; // z_omega(xi)
    uint16 constant pEval_Zw = 4 + 32*<%- commits * 2 + 13 %>; // z_omega(xi omega)
    uint16 constant pEval_T1w = 4 + 32*<%- commits * 2 + 14 %>; // T_1(xi omega)
    uint16 constant pEval_inv = 4 + 32*<%- commits * 2 + 15 %>; // inv(batch) sent by the prover to avoid any inverse calculation to save gas,
                                                                // we check the correctness of the inv(batch) by computing batch
                                                                // and checking inv(batch) * batch == 
    uint16 constant pEval_invPublics = 4 + 32*<%- commits * 2 + 16 %>;

    // Memory data
    // Challenges
    uint16 constant pBeta    = 0;  // beta challenge
    uint16 constant pGamma   = 32;  // gamma challenge
    uint16 constant pXiSeed  = 64; // xi seed, from this value we compute xi = xiSeed^24
    uint16 constant pXi      = 96; // xi challenge

    uint16 constant pPi     = 128; // PI(xi)

    uint16 constant pZh     = 160; // Z_H(xi)
    // From this point we write all the variables that must be computed using the Montgomery batch inversion
    uint16 constant pZhInv  = 192; // 1/Z_H(xi)
    <% let inversionArray = ["pZhInv"]; -%>
    <% for (let i = 0; i < Math.max(vk.nPublic, 1); i++) { %>
    uint16 constant pEval_L<%=i+1%> = <%= 224 + 32 * i %>;
    <% inversionArray.push(`pEval_L${i+1}`) -%>
    <% } %>
    <% let pLastMem = 224 + 32 * (Math.max(vk.nPublic,1)) %>
    uint16 constant lastMem = <%= pLastMem %>;
     
    constructor(
        address _shPlonkVerifier
    ) {
        shPlonkVerifierAddress = _shPlonkVerifier;
    }

    function verifyProof(bytes32[<%- 17 + commits * 2 %>] calldata proof, uint256[1] calldata pubSignals) public view returns (bool) {        
        bytes4 selectorShPlonk = bytes4(keccak256("verifyCommitments(bytes32[<%- 17 + commits * 2 - 1%>],bytes32,bytes32[3])"));

        assembly {
            // Computes the inverse of an array of values
            // See https://vitalik.ca/general/2018/07/21/starks_part_3.html in section where explain fields operations
            // To save the inverse to be computed on chain the prover sends the inverse as an evaluation in commits.eval_inv
            function inverseArray(pMem) {

                let pAux := mload(0x40)     // Point to the next free position
                let acc := mload(add(pMem,<%- inversionArray[0] %>))       // Read the first element
                mstore(pAux, acc)

<%  for(let i = 1; i < inversionArray.length; ++i) { -%>
                pAux := add(pAux, 32)
                acc := mulmod(acc, mload(add(pMem, <%- inversionArray[i] %>)), q)
                mstore(pAux, acc)

<% } -%>
                let inv := calldataload(pEval_invPublics)

                // Before using the inverse sent by the prover the verifier checks inv(batch) * batch === 1
                if iszero(eq(1, mulmod(acc, inv, q))) {
                    mstore(0, 0)
                    return(0,0x20)
                }

                acc := inv

<%  for(let i = inversionArray.length - 1; i > 0; --i) { -%>
                pAux := sub(pAux, 32)
                inv := mulmod(acc, mload(pAux), q)
                acc := mulmod(acc, mload(add(pMem, <%- inversionArray[i] %>)), q)
                mstore(add(pMem, <%- inversionArray[i] %>), inv)
<% } -%>
                mstore(add(pMem, <%- inversionArray[0] %>), acc)
            }
            
            function computeInverseValues(pMem) {
                // L_i where i from 1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)
                let w := 1
                let xi := mload(add(pMem, pXi))
                <% for (let i=1; i<=Math.max(vk.nPublic, 1); i++) { 
                %>mstore(add(pMem, pEval_L<%=i%>), mulmod(n, mod(add(sub(xi, w), q), q), q))
                <% if (i<Math.max(vk.nPublic, 1)) { 
                %>w := mulmod(w, w1, q)
                <% } 
                } %>
            }
            
            function computeChallenges(pMem, pPublic) {
                let mIn := mload(0x40)
                // Compute challenge.beta & challenge.gamma
<%  let fStage0 = vk.f.filter(fi => fi.stages[0].stage === 0)-%>
<%  for(let i = 0; i < fStage0.length; ++i) { -%>
                mstore(add(mIn,<%=  i * 64 %>), f<%= fStage0[i].index %>x)
                mstore(add(mIn,<%= i * 64 + 32 %>), f<%= fStage0[i].index %>y)
<%  } -%>

                mstore(add(mIn, <%= 64*fStage0.length %>), calldataload(pPublic))
<%for (let i=1; i<vk.nPublic;i++) { -%>
                mstore(add(mIn, <%= 64*fStage0.length + i * 32 %> ), calldataload(add(pPublic, <%= i * 32 %>)))
<%  } -%>
                

<%  let fStage1 = vk.f.filter(fi => fi.stages[0].stage === 1) -%>
<%  for(let i = 0; i < fStage1.length; ++i) { -%>
                mstore(add(mIn,<%- vk.nPublic * 32 + 64*(fStage0.length + i) %>), calldataload(pf<%= fStage1[i].index %>))
                mstore(add(mIn,<%- vk.nPublic * 32 + 64*(fStage0.length + i) + 32 %>), calldataload(add(pf<%= fStage1[i].index %>, 32)))
<%  } -%>
              
                mstore(add(pMem, pBeta),  mod(keccak256(mIn, <%= vk.nPublic * 32 + 64 * (fStage0.length + fStage1.length) %>), q))
                mstore(add(pMem, pGamma), mod(keccak256(add(pMem, pBeta), 32), q))

                // Get xiSeed 
                mstore(mIn, mload(add(pMem, pGamma)))
<%  let fStage2 = vk.f.filter(fi => fi.stages[0].stage === 2) -%>
<%  for(let i = 0; i < fStage2.length; ++i) { -%>
                mstore(add(mIn,<%- 32 + 64*i%>), calldataload(pf<%= fStage2[i].index %>))
                mstore(add(mIn,<%- 32 + 64*i + 32 %>), calldataload(add(pf<%= fStage2[i].index %>, 32)))
<%  } -%>
                let xiSeed := mod(keccak256(mIn, <%= 32 + 64*fStage2.length %>), q)

                mstore(add(pMem, pXiSeed), xiSeed)

                // Compute xin
                let xin := 1
<%  for ( let i = 0; i < vk.powerW; i++) { -%>
                xin:= mulmod(xin, xiSeed, q)
<%  }   -%>

                mstore(add(pMem, pXi), xin)

                // Compute xi^n
<%for ( let i = 0; i < vk.power; i++) { -%>
                xin:= mulmod(xin, xin, q)
<%  }   -%>
                
                xin:= mod(add(sub(xin, 1), q), q)
                mstore(add(pMem, pZh), xin)
                mstore(add(pMem, pZhInv), xin)  // We will invert later together with lagrange pols
            }


            // Compute Lagrange polynomial evaluation L_i(xi)
            function computeLagrange(pMem) {
                let zh := mload(add(pMem, pZh))
                let w := 1
                <% for (let i=1; i<=Math.max(vk.nPublic, 1); i++) { 
                    if (i===1) { %>
                    mstore(add(pMem, pEval_L1 ), mulmod(mload(add(pMem, pEval_L1 )), zh, q))
                    <% } else { %>
                    mstore(add(pMem, pEval_L<%=i%>), mulmod(w, mulmod(mload(add(pMem, pEval_L<%=i%>)), zh, q), q))
                    <% } 
                    if (i<Math.max(vk.nPublic, 1)) { %>
                    w := mulmod(w, w1, q)
                    <% } 
                } %>
            }

            // Compute public input polynomial evaluation PI(xi)
            function computePi(pMem, pPub) {
                let pi := 0
                pi := mod(add(sub(pi, mulmod(mload(add(pMem, pEval_L1)), calldataload(pPub), q)), q), q)
                <% for (let i=1; i<vk.nPublic; i++) { %>
                pi := mod(add(sub(pi, mulmod(mload(add(pMem, pEval_L<%= i + 1 %>)), calldataload(add(pPub, <%= 32 * i %>)), q)), q), q)
                <% } %>
                mstore(add(pMem, pPi), pi)
            }

            function computeT0(pMem)-> t0 {
                let evalA := calldataload(pEval_A)
                let evalB := calldataload(pEval_B)
                let evalC := calldataload(pEval_C)

                t0 := mulmod(calldataload(pEval_QL), evalA, q)
                t0 := addmod(t0, mulmod(calldataload(pEval_QR), evalB, q) ,q)
                t0 := addmod(t0, mulmod(calldataload(pEval_QM), mulmod(evalA, evalB, q), q) ,q)
                t0 := addmod(t0, mulmod(calldataload(pEval_QO), evalC, q) ,q)
                t0 := addmod(t0, calldataload(pEval_QC) ,q)
                t0 := addmod(t0, mload(add(pMem, pPi)), q)
                t0 := mulmod(t0, mload(add(pMem, pZhInv)), q)
            }

            function computeT1(pMem) -> t1 {
                t1 := sub(calldataload(pEval_Z), 1)
                t1 := mulmod(t1, mload(add(pMem, pEval_L1)) ,q)
                t1 := mulmod(t1, mload(add(pMem, pZhInv)) ,q)
            }

            function computeT2(pMem) -> t2 {
                let betaXi := mulmod(mload(add(pMem, pBeta)), mload(add(pMem, pXi)), q)
                let gamma := mload(add(pMem, pGamma))
                let evalZ := calldataload(pEval_Z)
                let evalZw := calldataload(pEval_Zw)

                t2 := addmod(calldataload( pEval_A), addmod(betaXi, gamma, q) ,q)
                t2 := mulmod(t2,
                            addmod(calldataload( pEval_B),
                            addmod(mulmod(betaXi, k1, q), gamma, q) ,q), q)
                t2 := mulmod(t2,
                            addmod(calldataload( pEval_C),
                            addmod(mulmod(betaXi, k2, q), gamma, q) ,q), q)
                t2 := mulmod(t2, evalZ, q)

                let t22
                t22 := addmod(calldataload(pEval_A), addmod(mulmod(mload(add(pMem, pBeta)), calldataload(pEval_Sigma1), q), gamma, q) ,q)
                t22 := mulmod(t22,
                      addmod(calldataload(pEval_B), addmod(mulmod(mload(add(pMem, pBeta)), calldataload(pEval_Sigma2), q), gamma, q) ,q), q)
                t22 := mulmod(t22,
                      addmod(calldataload(pEval_C), addmod(mulmod(mload(add(pMem, pBeta)), calldataload(pEval_Sigma3), q), gamma, q) ,q), q)
                t22 := mulmod(t22, evalZw, q)

                t2:= addmod(t2, mod(sub(q, t22), q), q)
                t2 := mulmod(t2, mload(add(pMem, pZhInv)), q)
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, lastMem))

            // Compute the challenges: beta, gamma, xi, xiN and zh(xi)
            computeChallenges(pMem, pubSignals)

            computeInverseValues(pMem)

            inverseArray(pMem)

            // Compute Lagrange polynomial evaluations Li(xi)
            computeLagrange(pMem)

            // Compute public input polynomial evaluation PI(xi) = \sum_i^l -public_input_iÂ·L_i(xi)
            computePi(pMem, pubSignals)
            
            let t0 := computeT0(pMem)
            let t1 := computeT1(pMem)
            let t2 := computeT2(pMem)

            mstore(pMem, selectorShPlonk)
            mstore(add(pMem, <%- 4 + (17 + commits * 2 - 1)*32 %>), mload(add(pMem, pXiSeed)))
            calldatacopy(add(pMem, 0x04), pW, <%- (17 + commits * 2 - 1)*32 %>)
            mstore(add(pMem, <%- 4 + (17 + commits * 2 - 1)*32 + 32 %>), t0)
            mstore(add(pMem, <%- 4 + (17 + commits * 2 - 1)*32 + 32*2 %>), t1)
            mstore(add(pMem, <%- 4 + (17 + commits * 2 - 1)*32 + 32*3 %>), t2)
            let success := staticcall(sub(gas(), 2000), sload(shPlonkVerifierAddress.slot), pMem, <%- 4 + (17 + commits * 2 - 1)*32 + 32*3 + 32 %>, pMem, 0x20)
            let isValid := and(success, mload(pMem))

            mstore(0, isValid)
            return(0,0x20)
        }
    }
}
